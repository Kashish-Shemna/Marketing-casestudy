# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15NtM443Gmpvkk4E7A6fCydhvcfT11jfM
"""

import streamlit as st
import pandas as pd
import numpy as np
import pickle
import statsmodels.api as sm

# ----------------- PAGE CONFIG -----------------
st.set_page_config(
    page_title="Campaign Response & Customer Segment",
    layout="centered"
)

# ----------------- LOAD PICKLE -----------------
with open("model_with_clusters.pkl", "rb") as f:
    artifacts = pickle.load(f)

clf_model = artifacts["classification_model"]          # result_new12
class_feature_names = artifacts["class_feature_names"]

cluster_model = artifacts["cluster_model"]             # kmeans_model_2  (not used now for predict)
cluster_feature_names = artifacts["cluster_feature_names"]
cluster_summary = artifacts["cluster_summary"]         # cluster_profiles_fixed

scaler = artifacts["scaler"]                           # min_max_scaler
scaler_feature_names = artifacts["raw_feature_names"]  # ['Income', 'Total_Expenditure_2yrs', 'Customer tenure(days)']

# ---- Detect which column in cluster_summary is the cluster id ----
cols = list(cluster_summary.columns)
label_candidates = [c for c in cols if "cluster" in c.lower()]

if "cluster_id" in cols:
    cluster_label_col = "cluster_id"
elif label_candidates:
    cluster_label_col = label_candidates[0]
else:
    cluster_label_col = cols[0]  # fallback

# ----------------- STYLING -----------------
st.markdown(
    """
    <style>
    .main {
        background-color: #f5f7fb;
    }
    .big-title {
        font-size: 32px;
        font-weight: 700;
        color: #1f2933;
        margin-bottom: 0.25rem;
    }
    .sub {
        color: #52606d;
        font-size: 15px;
        margin-top: 0;
        margin-bottom: 1rem;
    }
    .metric-card {
        padding: 0.75rem 1rem;
        border-radius: 0.75rem;
        background-color: #fdfdfd;
        border: 1px solid #e5e7eb;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.markdown(
    '<div class="big-title">üéØ Campaign Response & Customer Segment</div>',
    unsafe_allow_html=True
)
st.markdown(
    '<p class="sub">Answer a few questions to know your segment and the likelihood of responding to the next campaign.</p>',
    unsafe_allow_html=True
)

st.write("---")

# ----------------- INPUT UI -----------------

col1, col2 = st.columns(2)

with col1:
    income_choice = st.selectbox(
        "1. Income (per month)",
        [
            "less than 10000",
            "10000 - 30000",
            "30000 - 50000",
            "50000 - 70000",
            "70000 - 100000",
            "above 100000",
        ],
    )

with col2:
    exp_choice = st.selectbox(
        "2. Total expenditure in 2 years",
        [
            "less than 500",
            "500 - 1000",
            "1000 - 1500",
            "1500 - 2000",
            "2000 - 2500",
            "above 2500",
        ],
    )

tenure = st.number_input(
    "3. Customer tenure (days)",
    min_value=0,
    value=365,
    help="Number of days the customer has been with the company."
)

col3, col4, col5 = st.columns(3)

with col3:
    edu_choice = st.selectbox("4. Education (PhD)", ["No", "Yes"])

with col4:
    child_choice = st.selectbox("5. Children at home", ["No", "Yes"])

with col5:
    prev_choice = st.selectbox("6. Previous campaign response", ["No", "Yes"])


# ----------------- MAPPING FUNCTIONS -----------------

def map_income(choice: str) -> float:
    mapping = {
        "less than 10000": 5000,
        "10000 - 30000": 20000,
        "30000 - 50000": 40000,
        "50000 - 70000": 60000,
        "70000 - 100000": 85000,
        "above 100000": 120000,
    }
    return mapping[choice]


def map_expenditure(choice: str) -> float:
    mapping = {
        "less than 500": 250,
        "500 - 1000": 750,
        "1000 - 1500": 1250,
        "1500 - 2000": 1750,
        "2000 - 2500": 2250,
        "above 2500": 2750,
    }
    return mapping[choice]


def map_yes_no(choice: str) -> int:
    return 1 if choice == "Yes" else 0


# ----------------- PREDICTION -----------------

if st.button("üîç Analyse Customer"):
    # 1Ô∏è‚É£ Build numeric row for scaler features (Income, Total_Expenditure_2yrs, Customer tenure(days))
    numeric_row = []
    for feat in scaler_feature_names:
        f = feat.lower()
        if "income" in f:
            value = map_income(income_choice)
        elif "expenditure" in f or "exp" in f:
            value = map_expenditure(exp_choice)
        elif "tenure" in f:
            value = float(tenure)
        else:
            value = 0.0
        numeric_row.append(value)

    numeric_df = pd.DataFrame([numeric_row], columns=scaler_feature_names)

    # 2Ô∏è‚É£ Scale numeric features
    scaled_array = scaler.transform(numeric_df.values)
    scaled_numeric_df = pd.DataFrame(scaled_array, columns=scaler_feature_names)

    # 3Ô∏è‚É£ Binary features (names MUST match model‚Äôs columns)
    binary_values = {
        "Education_Phd": map_yes_no(edu_choice),
        "Children_at_home": map_yes_no(child_choice),
        "Prev_Campaign_Response": map_yes_no(prev_choice),
    }

    # 4Ô∏è‚É£ Build full model input row with all class_feature_names
    model_row = {}
    for feat in class_feature_names:
        if feat in scaled_numeric_df.columns:
            model_row[feat] = scaled_numeric_df[feat].iloc[0]
        elif feat in binary_values:
            model_row[feat] = binary_values[feat]
        else:
            model_row[feat] = 0.0

    X_class = pd.DataFrame([[model_row[feat] for feat in class_feature_names]],
                           columns=class_feature_names)
    X_class_const = sm.add_constant(X_class, has_constant="add")

    prob_yes = float(clf_model.predict(X_class_const)[0])
    pred_label = 1 if prob_yes >= 0.5 else 0

    # 5Ô∏è‚É£ Determine cluster by nearest centroid in cluster_summary
    #    Use only features that exist both in cluster_summary and scaled_numeric_df
    common_features = [
        c for c in cluster_summary.columns
        if c != cluster_label_col and c in scaled_numeric_df.columns
    ]

    if not common_features:
        # Fallback: assign first cluster
        cluster_id = int(cluster_summary[cluster_label_col].iloc[0])
        centroid_row = cluster_summary.iloc[0]
    else:
        user_vec = scaled_numeric_df[common_features].iloc[0].values.astype(float)
        centers = cluster_summary[common_features].values.astype(float)
        dists = np.linalg.norm(centers - user_vec, axis=1)
        best_idx = int(dists.argmin())
        centroid_row = cluster_summary.iloc[best_idx]
        cluster_id = int(centroid_row[cluster_label_col])

    # ------------ OUTPUT CARDS ------------
    st.write("---")
    col_a, col_b = st.columns(2)

    # 1Ô∏è‚É£ Campaign response prediction
    with col_a:
        st.subheader("üìå Campaign Response Prediction")
        if pred_label == 1:
            st.success(
                f"**Will likely respond to upcoming campaign.**  \n"
                f"Estimated probability of response: **{prob_yes:.2f}**"
            )
        else:
            st.warning(
                f"**Low likelihood of response to upcoming campaign.**  \n"
                f"Estimated probability of response: **{prob_yes:.2f}**"
            )

    # 2Ô∏è‚É£ Cluster info
    with col_b:
        st.subheader("üë• Customer Segment (Cluster)")
        st.info(
            f"Customer belongs to **Cluster {cluster_id}**."
        )

        # Show brief profile for this cluster using common features
        if common_features:
            st.markdown("**Cluster profile (scaled features):**")
            prof_lines = []
            for feat in common_features:
                prof_lines.append(f"- **{feat}** ‚âà `{centroid_row[feat]:.3f}`")
            st.markdown("\n".join(prof_lines))
        else:
            st.info("Cluster feature profile not available with current settings.")

    with st.expander("üìä See all clusters and their stats"):
        st.dataframe(cluster_summary)