# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15NtM443Gmpvkk4E7A6fCydhvcfT11jfM
"""

import streamlit as st
import pandas as pd
import pickle
import statsmodels.api as sm

# ----------------- PAGE CONFIG -----------------
st.set_page_config(
    page_title="Campaign Response & Customer Segment",
    layout="centered"
)

# ----------------- LOAD PICKLE -----------------
with open("model_with_clusters.pkl", "rb") as f:
    artifacts = pickle.load(f)

clf_model = artifacts["classification_model"]          # result_new12
class_feature_names = artifacts["class_feature_names"]

cluster_model = artifacts["cluster_model"]             # kmeans_model_2
cluster_feature_names = artifacts["cluster_feature_names"]
cluster_summary = artifacts["cluster_summary"]         # cluster_profiles

scaler = artifacts["scaler"]                           # min_max_scaler
scaler_feature_names = artifacts["raw_feature_names"]  # ['Income', 'Total_Expenditure_2yrs', 'Customer tenure(days)']

cluster_label_col = "cluster_id"                       # first column = cluster id

# ----------------- STYLING -----------------
st.markdown(
    """
    <style>
    .main {
        background-color: #f5f7fb;
    }
    .big-title {
        font-size: 32px;
        font-weight: 700;
        color: #1f2933;
        margin-bottom: 0.25rem;
    }
    .sub {
        color: #52606d;
        font-size: 15px;
        margin-top: 0;
        margin-bottom: 1rem;
    }
    </style>
    """,
    unsafe_allow_html=True
)

st.markdown(
    '<div class="big-title">ðŸŽ¯ Campaign Response & Customer Segment</div>',
    unsafe_allow_html=True
)
st.markdown(
    '<p class="sub">Answer a few questions to know your segment and the likelihood of responding to the next campaign.</p>',
    unsafe_allow_html=True
)

st.write("---")

# ----------------- INPUT UI -----------------

col1, col2 = st.columns(2)

with col1:
    income_choice = st.selectbox(
        "1. Income (per month)",
        [
            "less than 10000",
            "10000 - 30000",
            "30000 - 50000",
            "50000 - 70000",
            "70000 - 100000",
            "above 100000",
        ],
    )

with col2:
    exp_choice = st.selectbox(
        "2. Total expenditure in 2 years",
        [
            "less than 500",
            "500 - 1000",
            "1000 - 1500",
            "1500 - 2000",
            "2000 - 2500",
            "above 2500",
        ],
    )

tenure = st.number_input(
    "3. Customer tenure (days)",
    min_value=0,
    value=365,
    help="Number of days the customer has been with the company."
)

col3, col4, col5 = st.columns(3)

with col3:
    edu_choice = st.selectbox("4. Education (PhD)", ["No", "Yes"])

with col4:
    child_choice = st.selectbox("5. Children at home", ["No", "Yes"])

with col5:
    prev_choice = st.selectbox("6. Previous campaign response", ["No", "Yes"])


# ----------------- MAPPING FUNCTIONS -----------------

def map_income(choice: str) -> float:
    mapping = {
        "less than 10000": 5000,
        "10000 - 30000": 20000,
        "30000 - 50000": 40000,
        "50000 - 70000": 60000,
        "70000 - 100000": 85000,
        "above 100000": 120000,
    }
    return mapping[choice]


def map_expenditure(choice: str) -> float:
    mapping = {
        "less than 500": 250,
        "500 - 1000": 750,
        "1000 - 1500": 1250,
        "1500 - 2000": 1750,
        "2000 - 2500": 2250,
        "above 2500": 2750,
    }
    return mapping[choice]


def map_yes_no(choice: str) -> int:
    return 1 if choice == "Yes" else 0


# ----------------- PREDICTION -----------------

if st.button("ðŸ” Analyse Customer"):
    # 1ï¸âƒ£ Build numeric row directly based on the scaler feature names
    #    This avoids KeyErrors even if exact names differ slightly
    numeric_row = []
    for feat in scaler_feature_names:
        f = feat.lower()
        if "income" in f:
            value = map_income(income_choice)
        elif "expenditure" in f or "exp" in f:
            value = map_expenditure(exp_choice)
        elif "tenure" in f:
            value = float(tenure)
        else:
            # fallback if some unexpected column is present
            value = 0.0
        numeric_row.append(value)

    numeric_df = pd.DataFrame([numeric_row], columns=scaler_feature_names)


    # 2ï¸âƒ£ Scale numeric features
    scaled_array = scaler.transform(numeric_df.values)
    scaled_numeric_df = pd.DataFrame(scaled_array, columns=scaler_feature_names)

    # 3ï¸âƒ£ Binary features (column names must match your model)
    #    ðŸ” If your column names are slightly different, edit the keys below
    binary_values = {
        "Education_PhD": map_yes_no(edu_choice),
        "Children_at_home": map_yes_no(child_choice),
        "Prev_Campaign_Response": map_yes_no(prev_choice),
    }

    # 4ï¸âƒ£ Build full model input row with all class_feature_names
    model_row = {}
    for feat in class_feature_names:
        if feat in scaled_numeric_df.columns:
            # use scaled numeric value
            model_row[feat] = scaled_numeric_df[feat].iloc[0]
        elif feat in binary_values:
            # use binary value from dropdown
            model_row[feat] = binary_values[feat]
        else:
            # default 0 if some other feature exists in model
            model_row[feat] = 0.0

    X_class = pd.DataFrame([[model_row[feat] for feat in class_feature_names]],
                           columns=class_feature_names)
    X_class_const = sm.add_constant(X_class, has_constant="add")

    prob_yes = float(clf_model.predict(X_class_const)[0])
    pred_label = 1 if prob_yes >= 0.5 else 0

    # 5ï¸âƒ£ Clustering input using cluster_feature_names
    cluster_row = [model_row[feat] for feat in cluster_feature_names]
    X_cluster = pd.DataFrame([cluster_row], columns=cluster_feature_names)
    cluster_id = int(cluster_model.predict(X_cluster.values)[0])

    # 6ï¸âƒ£ Look up cluster behaviour
    row = cluster_summary[cluster_summary[cluster_label_col] == cluster_id]

    if row.empty:
        st.error("Cluster not found in summary table.")
    else:
        row = row.iloc[0]
        cluster_size = int(row["count"])
        yes_rate = float(row["response_yes_rate"])

        # ------------ OUTPUT CARDS ------------
        st.write("---")
        col_a, col_b = st.columns(2)

        # 1ï¸âƒ£ Will there be a response to upcoming campaign?
        with col_a:
            st.subheader("ðŸ“Œ Campaign Response Prediction")
            if pred_label == 1:
                st.success(
                    f"**Will likely respond to upcoming campaign.**  \n"
                    f"Estimated probability of response: **{prob_yes:.2f}**"
                )
            else:
                st.warning(
                    f"**Low likelihood of response to upcoming campaign.**  \n"
                    f"Estimated probability of response: **{prob_yes:.2f}**"
                )

        # 2ï¸âƒ£ Which cluster are they in?
        with col_b:
            st.subheader("ðŸ‘¥ Customer Segment (Cluster)")
            st.info(
                f"Customer belongs to **Cluster {cluster_id}** "
                f"(Size: **{cluster_size}** customers)."
            )

            if yes_rate >= 0.7:
                st.success(
                    f"This is a **high-response cluster** "
                    f"(historical response rate: **{yes_rate:.2f}**)."
                )
            elif yes_rate <= 0.3:
                st.error(
                    f"This is a **low-response cluster** "
                    f"(historical response rate: **{yes_rate:.2f}**)."
                )
            else:
                st.warning(
                    f"This is a **mixed cluster** "
                    f"(historical response rate: **{yes_rate:.2f}**)."
                )

        with st.expander("ðŸ“Š See all clusters and their response behaviour"):
            st.dataframe(cluster_summary)